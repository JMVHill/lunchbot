#!/usr/bin/env python

LUNCHBOT_FNAME_RATINGS = "lunchbot-ratings.txt"
LUNCHBOT_FNAME_RATEE = "lunchbot-current.txt"

def lunchbot_maybe_load():
    destinations = dict()
    try:
        with open(LUNCHBOT_FNAME_RATINGS, 'r') as f:
            current_destination = None
            while True:
                line = f.readline()
                line = line.rstrip('\n')
                if line == '':
                    break

                if line[-1] == ':':
                    # destination
                    current_destination = line[:-1]
                    destinations[current_destination] = Rating()
                else:
                    # <rating>: <user>
                    if current_destination is None:
                        raise ValueError()

                    rating_raw, user = line.split(':', 1)
                    rating_num = int(rating_raw)
                    user = user.strip()

                    current_rating = destinations[current_destination]
                    current_rating.add_rating(rating_num, user)
    except:
        pass

    index = 0
    try:
        with open(LUNCHBOT_FNAME_RATEE, 'r') as f:
            line = f.readline()
            line = line.rstrip('\n')
            index = int(line)
    except:
        pass

    return (destinations, index)

def lunchbot_save(destinations, index):
    try:
        with open(LUNCHBOT_FNAME_RATINGS, 'w') as f:
            for destination in destinations:
                f.write("{}:\n".format(destination));

                ratings = destinations[destination].getall()
                for user in ratings:
                    rating = ratings[user]
                    f.write('  {}: {}\n'.format(str(rating), user));

        with open(LUNCHBOT_FNAME_RATEE, 'w') as f:
            f.write('{}\n'.format(index))

    except IOError as e:
        print >>sys.stderr, "exception saving state: {}".format(e)


class Rating():
    def __init__(self):
        self.ratings = dict() # string => int

    def add_rating(self, rating, rater):
        self.ratings[rater] = rating

    def has_user_rating(self, rater):
        return rater in self.ratings


    def average(self):
        if len(self.ratings) == 0:
            return 0
        return sum(self.ratings.values()) / float(len(self.ratings))

    def getall(self):
        return self.ratings

class Bot():
    def __init__(self, slackconnection, botname):
        self.botname = botname
        self.slackconnection = slackconnection
        self.channel = None

    def send_message(self, text):
        # post as BOT_NAME instead of the current user
        self.slackconnection.api_call(
                "chat.postMessage",
                channel = self.channel.id,
                text = text,
                username = self.botname,
                as_user = False)

    def send_list(self, prefix, list):
        self.send_message("{}: {}".format(prefix, ', '.join(list)))

    def handle_message(self, message):
        return False # abstract

    def set_current_channel(self, channel):
        self.channel = channel

class LunchBot(Bot):
    def __init__(self, slackconnection, botname):
        Bot.__init__(self, slackconnection, botname)

        self.destinations = dict() # string => Rating
        self.luncher_index = 0
        self.load()

    def load(self):
        self.destinations, self.luncher_index = lunchbot_maybe_load()

    def teardown(self):
        lunchbot_save(self.destinations, self.luncher_index)

    def send_usage(self):
        message = '\n'.join([
                "usage: ```lunchbot [subcommand]",
                "Common usage:",
                "  suggest",
                "    Suggest a luncher to pick a destination, and a possible destination",
                "  visited <destination> <luncher>",
                "    Record destination and who chose it",
                "",
                "Other commands:",
                "  add <destination>           - Add an unvisited destination",
                "  list                        - List all destinations",
                "  rate <destination> <rating> - Rate a destination (as your user)",
                "  usage | help                - Show this",
                "```"
                ])

        self.send_message(message)

    def send_usage_small(self, to_user):
        self.send_message("<@{}>: didn't understand that. `lunchbot usage` for details".format(to_user))

    def send_destinations(self, verbose):
        message = "{} destinations:\n".format(len(self.destinations))

        sorted_dests = sorted(
                self.destinations,
                key=lambda d: self.destinations[d].average(),
                reverse=True)

        for dest in sorted_dests:
            rating = self.destinations[dest]
            rating_avg = rating.average()
            message += '>  `%02.2f`\t%s' % (rating_avg, dest)
            if verbose:
                message += ' ('
                dest_ratings = rating.getall()
                message += ', '.join(
                        map(lambda user: '{} from <@{}>'.format(dest_ratings[user], user),
                            dest_ratings))
                message += ')'
            message += '\n'

        self.send_message(message)

    def get_top_destination(self):
        top = None
        top_rating = 0
        for dest in self.destinations:
            cur_rating = self.destinations[dest].average()
            if cur_rating >= top_rating:
                top = dest
                top_rating = cur_rating
        return top

    def suggest(self, channel):
        luncher_message = "no lunchers to choose from"
        lunchers = channel.members
        if len(lunchers) > 0:
            if self.luncher_index >= len(lunchers):
                self.luncher_index = 0
            luncher = lunchers[self.luncher_index]
            luncher_message = "it's <@{}>'s turn to choose".format(luncher)

        destination_message = "no destinations to choose from"
        top = self.get_top_destination()
        if top is not None:
            destination_message = '{} is currently favourite'.format(top)

        self.send_message("{} - {}".format(luncher_message, destination_message))

    def visited(self, message, args):
        self.send_message("`lunchbot visited` not implemented")

    def handle_rating(self, message, args):
        tokens = args.split()

        if len(tokens) == 0:
            self.send_usage_small(message.user)
            return

        rating_str = tokens[-1] # last entry
        rating_int = 0
        try:
            rating_int = int(rating_str)
            if rating_int < 0 or rating_int > 100:
                raise ValueError()
        except ValueError:
            self.send_message("'{}' not an integer between 0 and 100".format(rating_str))
            return

        user = message.user # note - this is the slack id, not the real name
        destination = ' '.join(tokens[:-1])
        if destination in self.destinations.keys():
            rating = self.destinations[destination]
            add_or_mod = 'modified' if rating.has_user_rating(user) else 'added'
            rating.add_rating(rating_int, user)

            self.send_message("{} rating for '{}' (as <@{}>)".format(add_or_mod, destination, user))
        else:
            self.send_message("'{}' doesn't exist as a destination".format(destination))

    def handle_command(self, message, command, rest):
        if command == 'suggest':
            if len(rest) > 0:
                self.send_usage_small(message.user)
                return

            self.suggest(message.channel)

        elif command == 'visited':
            if len(rest) > 0:
                self.send_usage_small(message.user)
                return

            self.visited(message, rest)

        elif command == 'usage' or command == 'help':
            self.send_usage()

        elif command == 'list':
            verbose = False
            if rest == '-v':
                verbose = True
            elif rest != '':
                self.send_usage_small(message.user)
                return

            self.send_destinations(verbose)

        elif command == 'add':
            destination = rest

            if len(destination) == 0:
                self.send_usage_small(message.user)
                return

            if destination in self.destinations.keys():
                self.send_message("'{}' already exists".format(destination))
            elif destination.count(':') > 0:
                self.send_message("destinations can't contain a colon")
            else:
                self.destinations[destination] = Rating()
                self.send_message("'{}' added".format(destination))

        elif command == 'rate':
            self.handle_rating(message, rest)

        else:
            self.send_usage_small(message.user)

    def handle_message(self, message):
        tokens = message.text.split()
        if len(tokens) < 2 or tokens[0] != "lunchbot":
            return False
        self.handle_command(message, tokens[1], ' '.join(tokens[2:]))

class DumpBot(Bot):
    def __init__(self, slackconnection, botname):
        Bot.__init__(self, slackconnection, botname)

    def handle_message(self, message):
        print "got message from '{}': '{}'".format(message.user, message.text)

    def teardown(self):
        pass

class SlackMessage():
    def __init__(self, text, user, channel, reply_to, bot_id):
        self.text = text
        self.user = user
        self.channel = channel
        self.reply_to = reply_to # may be None
        self.bot_id = bot_id # may be None

class SlackMonitorConnectError():
    pass

class SlackMonitor():
    def __init__(self, slackconnection):
        self.slackconnection = slackconnection
        self.handlers = dict()
        if not slackconnection.rtm_connect():
            raise SlackMonitorConnectError()

    def add_handler_for_channel(self, handler, channel):
        if channel not in self.handlers:
            self.handlers[channel] = []
        self.handlers[channel].append(handler)

    def run(self):
        while True:
            for slack_message in self.slackconnection.rtm_read():
                if slack_message.get("type") is None:
                    continue

                text = slack_message.get("text")
                user = slack_message.get("user")
                channel_id = slack_message.get("channel")
                reply_to = slack_message.get("reply_to")
                bot_id = slack_message.get("bot_id")

                channel = channel_id # safe fallback
                for i in self.slackconnection.server.channels:
                    if i.id == channel_id:
                        channel = i
                        break

                if not text or not user or not channel:
                    continue

                if channel.name not in self.handlers:
                    continue

                message = SlackMessage(text, user, channel, reply_to, bot_id)
                for handler in self.handlers[channel.name]:
                    handler.set_current_channel(channel)
                    handler.handle_message(message)

            time.sleep(0.1)

    def teardown(self):
        for channel in self.handlers:
            for bot in self.handlers[channel]:
                bot.teardown()

import time
from slackclient import SlackClient
import signal
import sys

if len(sys.argv) != 2:
    print >>sys.stderr, "Usage: {} channel".format(sys.argv[0])
    sys.exit(1)
arg_channel = sys.argv[1]

# bot constants
BOT_TOKEN = "<redacted>"

# global slack connection
slackconnection = SlackClient(BOT_TOKEN)

# setup channel monitoring
lunchbot = LunchBot(slackconnection, "lunchbot")
dumpbot = DumpBot(slackconnection, "dumpbot")

slackmonitor = SlackMonitor(slackconnection)
slackmonitor.add_handler_for_channel(lunchbot, arg_channel)

# catch SIGINT, cleanup before exit
def interrupt_handler(signal, frame):
    global slackmonitor
    slackmonitor.teardown()
    sys.exit(2)
signal.signal(signal.SIGINT, interrupt_handler)

# and begin
print "connected, watching #{}...".format(arg_channel)
slackmonitor.run()
