#!/usr/bin/env python

LUNCHBOT_FNAME_RATINGS = "lunchbot-ratings.txt"
LUNCHBOT_FNAME_LUNCHERS = "lunchbot-lunchers.txt"

def lunchbot_maybe_load():
    try:
        destinations = dict()
        with open(LUNCHBOT_FNAME_RATINGS, 'r') as f:
            while True:
                line = f.readline()
                if line == '':
                    break
                line = line.rstrip('\n')

                destination, ratings_raw = line.split(':', 1)
                ratings_numeric = ratings_raw.split()

                rating = Rating()
                for i in ratings_numeric:
                    rating.add_rating(int(i))

                destinations[destination] = rating

        lunchers = set()
        with open(LUNCHBOT_FNAME_LUNCHERS, 'r') as f:
            while True:
                line = f.readline()
                if line == '':
                    break
                lunchers.append(line.rstrip('\n'))

        return (destinations, lunchers)

    except:
        return (None, None)

def lunchbot_save(destinations, lunchers):
    try:
        with open(LUNCHBOT_FNAME_RATINGS, 'w') as f:
            for destination in destinations:
                f.write("{}: {}\n".format(
                    destination,
                    ' '.join(str(x) for x in destinations[destination].getall())))

        with open(LUNCHBOT_FNAME_LUNCHERS, 'w') as f:
            for luncher in lunchers:
                f.write("{}\n".format(luncher))

    except IOError as e:
        print >>sys.stderr, "exception saving state: {}".format(e)


class Rating():
    def __init__(self):
        self.ratings = []

    def add_rating(self, rating):
        self.ratings.append(rating)

    def average(self):
        if len(self.ratings) == 0:
            return 0
        return sum(self.ratings) / float(len(self.ratings))

    def getall(self):
        return self.ratings

class Bot():
    def __init__(self, slackconnection, botname):
        self.botname = botname
        self.slackconnection = slackconnection
        self.channel_id = None

    def send_message(self, text):
        # post as BOT_NAME instead of the current user
        self.slackconnection.api_call(
                "chat.postMessage",
                channel = self.channel_id,
                text = text,
                username = self.botname,
                as_user = False)

    def send_list(self, prefix, list):
        self.send_message("{}: {}".format(prefix, ', '.join(list)))

    def handle_message(self, message):
        return False # abstract

    def set_current_channel_id(self, channel_id):
        self.channel_id = channel_id

class LunchBot(Bot):
    def __init__(self, slackconnection, botname):
        Bot.__init__(self, slackconnection, botname)

        self.destinations = dict() # string => Rating
        self.lunchers = set()
        self.load()

    def load(self):
        destinations, lunchers = lunchbot_maybe_load()
        if destinations is not None:
            self.destinations = destinations
        if lunchers is not None:
            self.lunchers = lunchers

    def teardown(self):
        lunchbot_save(self.destinations, self.lunchers)

    def send_usage(self):
        message = '\n'.join([
                "usage: ```lunchbot [subcommand]",
                "  destination add <destination>",
                "  destination list",
                "  destination rate <destination> <rating>",
                "  luncher seed <lunchers...>",
                "  luncher list",
                "  luncher suggest",
                "```"
                ])

        self.send_message(message)

    def send_destinations(self):
        self.send_message("{} destinations:".format(len(self.destinations)))

        for dest in self.destinations:
            rating_avg = self.destinations[dest].average()
            self.send_message("'{}', rating average: {}".format(dest, round(rating_avg, 2)))

    def send_lunchers(self):
        self.send_message("lunchers: {}".format(', '.join(self.lunchers)))

    def suggest_luncher(self):
        self.send_message("suggest_luncher unimplemented") # TODO

    def handle_subcommand_destination(self, message, command):
        if len(command) < 1:
            self.send_usage()
            return

        if command == 'list':
            self.send_destinations()
            return

        # add <dest> or rate <dest> <int>
        tokens = command.split(' ')
        if tokens[0] == 'add':
            destination = ' '.join(tokens[1:])
            if destination in self.destinations.keys():
                self.send_message("'{}' already exists".format(destination))
            else:
                self.destinations[destination] = Rating()
                self.send_message("'{}' added".format(destination))

        elif tokens[0] == 'rate':
            rating_str = tokens[-1] # last entry
            rating = 0
            try:
                rating = int(rating_str)
                if rating < 0 or rating > 100:
                    raise ValueError()
            except ValueError:
                self.send_message("'{}' not an integer between 0 and 100".format(rating_str))
                return

            destination = ' '.join(tokens[1:-1])
            if destination in self.destinations.keys():
                self.destinations[destination].add_rating(rating)
                self.send_message("added rating for '{}'".format(destination))
            else:
                self.send_message("'{}' doesn't exist as a destination".format(destination))

        else:
            self.send_usage()

    def handle_subcommand_luncher(self, message, command):
        # seed <lunchers>, list, or suggest

        if len(command) < 1:
            self.send_usage()
            return

        if command == 'list':
            self.send_lunchers()
            return
        elif command == 'suggest':
            self.suggest_luncher()
            return

        tokens = command.split()

        if tokens[0] == 'seed':
            self.lunchers = tokens[1:]
            self.send_message("accepted new set of lunchers")
        else:
            self.send_usage()

    def handle_command(self, message, command, rest):
        if command == "destination":
            self.handle_subcommand_destination(message, rest)

        elif command == "luncher":
            self.handle_subcommand_luncher(message, rest)

        else:
            self.send_message("EH?!? what you on about <@{}>??".format(message.user))
            self.send_usage()

        return True

    def handle_message(self, message):
        tokens = message.text.split()
        if len(tokens) < 2 or tokens[0] != "lunchbot":
            return False
        return self.handle_command(message, tokens[1], ' '.join(tokens[2:]))

class DumpBot(Bot):
    def __init__(self, slackconnection, botname):
        Bot.__init__(self, slackconnection, botname)

    def handle_message(self, message):
        print "got message from '{}': '{}'".format(message.user, message.text)

        return True

    def teardown(self):
        pass

class SlackMessage():
    def __init__(self, text, user, channel, reply_to, bot_id):
        self.text = text
        self.user = user
        self.channel = channel
        self.reply_to = reply_to # may be None
        self.bot_id = bot_id # may be None

class SlackMonitorConnectError():
    pass

class SlackMonitor():
    def __init__(self, slackconnection):
        self.slackconnection = slackconnection
        self.handlers = dict()
        if not slackconnection.rtm_connect():
            raise SlackMonitorConnectError()

    def add_handler_for_channel(self, handler, channel):
        if channel not in self.handlers:
            self.handlers[channel] = []
        self.handlers[channel].append(handler)

    def run(self):
        while True:
            for slack_message in self.slackconnection.rtm_read():
                if slack_message.get("type") is None:
                    continue

                text = slack_message.get("text")
                user = slack_message.get("user")
                channel_id = slack_message.get("channel")
                reply_to = slack_message.get("reply_to")
                bot_id = slack_message.get("bot_id")

                channel = channel_id # safe fallback
                for i in self.slackconnection.server.channels:
                    if i.id == channel_id:
                        channel = i.name
                        break

                if not text or not user or not channel:
                    continue

                if channel not in self.handlers:
                    continue

                message = SlackMessage(text, user, channel, reply_to, bot_id)
                for handler in self.handlers[channel]:
                    handler.set_current_channel_id(channel_id)
                    handler.handle_message(message)

            time.sleep(0.1)

    def teardown(self):
        for channel in self.handlers:
            for bot in self.handlers[channel]:
                bot.teardown()

import time
from slackclient import SlackClient
import signal
import sys

# bot constants
BOT_TOKEN = "<redacted>"

# global slack connection
slackconnection = SlackClient(BOT_TOKEN)

# setup channel monitoring
lunchbot = LunchBot(slackconnection, "lunchbot")
dumpbot = DumpBot(slackconnection, "dumpbot")

slackmonitor = SlackMonitor(slackconnection)
slackmonitor.add_handler_for_channel(lunchbot, "_testbot")
#slackmonitor.add_handler_for_channel(dumpbot, "_testbot")

# catch SIGINT, cleanup before exit
def interrupt_handler(signal, frame):
    global slackmonitor
    slackmonitor.teardown()
    sys.exit(2)
signal.signal(signal.SIGINT, interrupt_handler)

# and begin
slackmonitor.run()
